
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>SIS - Arduino - Структура программы на языке C++ для Arduino</title>

    <!-- Bootstrap core CSS -->
    <link href="../bootstrap.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="../custom.css" rel="stylesheet">

    <link rel="stylesheet" href="../monokai_sublime.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body>

    <div class="container">

      <!-- Static navbar -->
      <nav class="navbar navbar-default">
        <div class="container-fluid">
          <div class="navbar-header">
            <img src="http://10.0.0.2/mail/logo.png" height="50px;" class="navbar-logo"/>
            <div class="navbar-brand">Arduino club</div>
          </div>
        </div><!--/.container-fluid -->
      </nav>

    <ol class="breadcrumb">
      <li><a href="../index.html">Главная</a></li>
      <li class="active">Структура программы на языке C++ для Arduino</li>
    </ol>

      <!-- Main component for a primary marketing message or call to action -->
      <div class="jumbotron">
        <div class="row">
            <h2>Структура программы на языке C++ для Arduino</h2>
<div class="level1">

<p>

Рассмотрим пример минимально возможной программы на C++ для Arduino,
которая ничего не делает:
</p>
</br>
<pre>
<code class="c++">void setup()
{
}
 
void loop()
{
}
</code>
</pre>
<p>
Разберёмся что здесь написано и почему это обязательно: почему нельзя
обойтись просто пустым файлом.
</p>

</div>

<h2 class="sectionedit2">Из чего состоит программа</h2>
<div class="level2">

<p>

Для начала стоит понять, что программу нельзя читать и писать как книгу:
от корки до корки, сверху вниз, строку за строкой. Любая программа состоит
из отдельных блоков. Начало блока кода в C/C++ обозначается левой фигурной
скобкой <code>{</code>, его конец — правой фигурной скобкой <code>}</code>.
</p>

<p>
Блоки бывают разных видов и какой из них когда будет исполняться зависит от внешних
условий. В примере минимальной программы вы можете видеть 2 блока. В этом
примере блоки называются <em>определением функции</em>. Функция — это просто
блок кода с заданным именем, которым кто-то затем может пользоваться из-вне.
</p>

<p>
В данном случае у нас 2 функции с именами <code>setup</code> и <code>loop</code>. Их присутствие обязательно
в любой программе на C++ для Arduino. Они могут ничего и не делать, как в нашем случае,
но должны быть написаны. Иначе на стадии компиляции вы получите ошибку.
</p>

</div>

<h2 class="sectionedit3">Классика жанра: мигающий светодиод</h2>
<div class="level2">

<p>

Давайте теперь дополним нашу программу так, чтобы происходило хоть что-то.
На Arduino, к 13-му пину подключён светодиод. Им можно управлять, чем мы и займёмся.
</p>
<br>
<pre class="code cpp">
<code class="c++">void setup()
{
    pinMode(13, OUTPUT);
}
 
void loop()
{
    digitalWrite(13, HIGH);
    delay(100);
    digitalWrite(13, LOW);
    delay(900);
}
</code>
</pre>

<p>
Скомпилируйте, загрузите программу. Вы увидите, что каждую секунду светодиод на плате
помигивает. Разберёмся почему этот код приводит к ежесекундному миганию.
</p>

<p>
В наши ранее пустые функции мы добавили несколько <em>выражений</em>. Они были размещены между
фигурными скобками функций <code>setup</code> и <code>loop</code>. В <code>setup</code> появилось одно выражение, а в
<code>loop</code> сразу 4.
</p>

<p>
Каждое выражение — это приказ процессору сделать нечто. Выражения в рамках одного
блока исполняются одно за другим, строго по порядку без всяких пауз и переключений.
То есть, если мы говорим об одном конкретном блоке кода, его можно читать сверху вниз,
чтобы понять что делается.
</p>

<p>
Теперь давайте поймём в каком порядке исполняются сами блоки, т.е. функции <code>setup</code> и <code>loop</code>.
Не задумывайтесь пока что значат конкретные выражения, просто понаблюдайте за порядком.
</p>
<ul>
<li class="level1"><div class="li"> Как только Arduino включается, перепрошивается или нажимается кнопка <code>RESET</code>, «нечто» <em>вызывает функцию</em> <code>setup</code>. То есть заставляет исполняться выражения в ней.</div>
</li>
<li class="level1"><div class="li"> Как только работа <code>setup</code> завершается, сразу же «нечто» вызывает функцию <code>loop</code>.</div>
</li>
<li class="level1"><div class="li"> Как только работа <code>loop</code> завершается, сразу же «нечто» вызывает функцию <code>loop</code> ещё раз и так до бесконечности.</div>
</li>
</ul>

<p>

Если пронумеровать выражения по порядку, как они исполняются, получится:
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(13, OUTPUT);     ❶
}
 
void loop()
{
    digitalWrite(13, HIGH);  ❷    ❻    ❿
    delay(100);              ❸    ❼    …
    digitalWrite(13, LOW);   ❹    ❽ 
    delay(900);              ❺    ❾ 
}</code></pre>

<p>
Ещё раз напомним, что не стоит пытаться воспринимать всю программу, читая сверху вниз.
Сверху вниз читается только содержимое блоков. Мы вообще можем поменять порядок объявлений
<code>setup</code> и <code>loop</code>. 
</p>
<br>
<pre><code class="c++">void loop()
{
    digitalWrite(13, HIGH);  ❷    ❻    ❿
    delay(100);              ❸    ❼    …
    digitalWrite(13, LOW);   ❹    ❽ 
    delay(900);              ❺    ❾ 
}
 
void setup()
{
    pinMode(13, OUTPUT);     ❶
}</code></pre>

<p>
Результат от этого не изменится ни на йоту: после компиляции вы получите абсолютно эквивалентный
бинарный файл.

</p>

</div>

<h2 class="sectionedit4">Что делают выражения</h2>
<div class="level2">

<p>

Теперь давайте попробуем понять почему написанная программа приводит в итоге к миганию светодиода.
</p>

<p>
Как известно, пины Arduino могут работать и как выходы и как входы. Когда мы хотим чем-то управлять,
то есть выдавать сигнал, нам нужно перевести управляющий пин в состояние работы на выход. В нашем
примере мы управляем светодиодом на 13-м пине, поэтому 13-й пин перед использованием нужно сделать
выходом.
</p>

<p>
Это делается выражением в функции <code>setup</code>:
</p>
<br>
<pre><code class="c++">pinMode(13, OUTPUT);</code></pre>

<p>
Выражения бывают разными: арифметическими, декларациями, определениями, условными и т.д. В данном
случае мы в выражении осуществляем <em>вызов функции</em>. Помните? У нас есть <em>свои</em> функции <code>setup</code> и
<code>loop</code>, которые вызываются чем-то, что мы назвали «нечто». Так вот теперь <em>мы</em> вызываем функции,
которые уже написаны где-то.
</p>

<p>
Конкретно в нашем <code>setup</code> мы вызываем функцию с именем <code>pinMode</code>. Она устанавливает заданный по номеру пин
в заданный режим: вход или выход. О каком пине и о каком режиме идёт речь указывается нами в круглых
скобках, через запятую, сразу после имени функции. В нашем случае мы хотим, чтобы 13-й пин работал
как выход. <code>OUTPUT</code> означает выход, <code>INPUT</code> — вход.
</p>

<p>
Уточняющие значения, такие как <code>13</code> и <code>OUTPUT</code> называются <em>аргументами функции</em>. Совершенно не обязательно,
что у всех функций должно быть по 2 аргумента. Сколько у функции аргументов зависит от сути функции,
от того как её написал автор. Могут быть функции с одним аргументом, тремя, двадцатью; функции могут
быть без аргументов вовсе. Тогда для их вызова круглые скобка открывается и тут же закрывается:
</p>
<br>
<pre><code class="c++">noInterrupts();</code></pre>

<p>
На самом деле, вы могли заметить, наши функции <code>setup</code> и <code>loop</code> также не принимают никакие аргументы.
И загадочное «нечто» точно так же вызывает их с пустыми скобками в нужный момент.
</p>

<p>
Вернёмся к нашему коду. Итак, поскольку мы планируем вечно мигать светодиодом, управляющий пин должен
один раз быть сделан выходом и затем мы не хотим вспоминать об этом. Для этого идеологически и
предназначена функция <code>setup</code>: настроить плату как нужно, чтобы затем с ней работать.
</p>

<p>
Перейдём к функции <code>loop</code>:
</p>
<br>
<pre><code class="c++">void loop()
{
    digitalWrite(13, HIGH);
    delay(100);
    digitalWrite(13, LOW);
    delay(900);
}</code></pre>

<p>
Она, как говорилось, вызывается сразу после <code>setup</code>. И вызывается снова и снова как только сама заканчивается.
Функция <code>loop</code> называется основным циклом программы и идеологически предназначена для выполнения полезной
работы. В нашем случае полезная работа — мигание светодиодом.
</p>

<p>
Пройдёмся по выражениям по порядку. Итак, первое выражение — это вызов встроенной функции <code>digitalWrite</code>.
Она предназначена для подачи на заданный пин логического нуля (<code>LOW</code>, 0 вольт) или логической единицы (<code>HIGH</code>, 5 вольт)
В функцию <code>digitalWrite</code> передаётся 2 аргумента: номер пина и логическое значение. В итоге, первым делом
мы зажигаем светодиод на 13-м пине, подавая на него 5 вольт.
</p>

<p>
Как только это сделано процессор моментально приступает к следующему выражению. У нас это вызов функции <code>delay</code>.
Функция <code>delay</code> — это, опять же, встроенная функция, которая заставляет процессор уснуть на определённое время.
Она принимает всего один аргумент: время в миллисекундах, которое следует спать. В нашем случае это 100 мс.
</p>

<p>
Пока мы спим всё остаётся как есть, т.е. светодиод продолжает гореть. Как только 100 мс истекают, процессор
просыпается и тут же переходит к следующему выражению. В нашем примере это снова вызов знакомой нам встроенной
функции <code>digitalWrite</code>. Правда на этот раз вторым аргументом мы передаём значение <code>LOW</code>. То есть устанавливаем
на 13-м пине логический ноль, то есть подаём 0 вольт, то есть гасим светодиод.
</p>

<p>
После того, как светодиод погашен мы приступаем к следующему выражению. И снова это вызов функции <code>delay</code>.
На этот раз мы засыпаем на 900 мс.
</p>

<p>
Как только сон окончен, функция <code>loop</code> завершается. По факту завершения «нечто» тут же вызывает её ещё раз
и всё происходит снова: светодиод поджигается, горит, гаснет, ждёт и т.д.
</p>

<p>
Если перевести написанное на русский, получится следующий алгоритм:

</p>
<ol>
<li class="level1"><div class="li"> Поджигаем светодиод</div>
</li>
<li class="level1"><div class="li"> Спим 100 миллисекунд</div>
</li>
<li class="level1"><div class="li"> Гасим светодиод</div>
</li>
<li class="level1"><div class="li"> Спим 900 миллисекунд</div>
</li>
<li class="level1"><div class="li"> Переходим к пункту 1</div>
</li>
</ol>

<p>

Таким образом мы получили Arduino с маячком, мигающим каждые 100 + 900 мс = 1000 мс = 1 сек.
</p>

</div>

<h2 class="sectionedit5">Что можно изменить</h2>
<div class="level2">

<p>

Давайте пользуясь только полученными знаниями сделаем несколько вариаций программы, чтобы лучше понять
принцип.
</p>

<p>
Вы можете подключить внешний светодиод или другое устройство, которым нужно «мигать» на другой пин.
Например, на 5-й. Как в этом случае должна измениться программа? Мы должны всюду, где обращались к 13-му
пину заменить номер на 5-й:
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT);
}
 
void loop()
{
    digitalWrite(5, HIGH);
    delay(100);
    digitalWrite(5, LOW);
    delay(900);
}</code></pre>

<p>
Компилируйте, загружайте, проверяйте.
</p>

<p>
Что нужно сделать, чтобы светодиод мигал 2 раза в секунду? Уменьшить время сна так, чтобы в сумме получилось
500 мс:
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT);
}
 
void loop()
{
    digitalWrite(5, HIGH);
    delay(50);
    digitalWrite(5, LOW);
    delay(450);
}</code></pre>

<p>
Как сделать так, чтобы светодиод при каждом «подмигивании» мерцал дважды? Нужно поджигать его дважды с небольшой
паузой между включениями:
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT);
}
 
void loop()
{
    digitalWrite(5, HIGH);
    delay(50);
    digitalWrite(5, LOW);
    delay(50);
    digitalWrite(5, HIGH);
    delay(50);
    digitalWrite(5, LOW);
    delay(350);
}</code></pre>

<p>
Как сделать так, чтобы в устройстве были 2 светодиода, которые мигали бы каждую секунду поочерёдно? Нужно
общаться с двумя пинами и работать в <code>loop</code> то с одним, то с другим:
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT);
    pinMode(6, OUTPUT);
}
 
void loop()
{
    digitalWrite(5, HIGH);
    delay(100);
    digitalWrite(5, LOW);
    delay(900);
    digitalWrite(6, HIGH);
    delay(100);
    digitalWrite(6, LOW);
    delay(900);
}</code></pre>

<p>
Как сделать так, чтобы в устройстве были 2 светодиода, которые переключались бы на манер железнодорожного светофора:
горел бы то один то другой? Нужно просто не выключать горящий светодиод тут же, а дожидаться момента переключения:
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT);
    pinMode(6, OUTPUT);
}
 
void loop()
{
    digitalWrite(5, HIGH);
    digitalWrite(6, LOW);
    delay(1000);
    digitalWrite(5, LOW);
    digitalWrite(6, HIGH);
    delay(1000);
}</code></pre>

<p>
Можете проверить другие идеи самостоятельно. Как видите, всё просто!
</p>

</div>

<h2 class="sectionedit6">О пустом месте и красивом коде</h2>
<div class="level2">

<p>

В языке C++ пробелы, переносы строк, символы табуляции не имеют большого значения для компилятора.
Там где стоит пробел, может быть перенос строки и наоборот. На самом деле 10 пробелов подряд,
2 переноса строки и ещё 5 пробелов — это всё эквивалент одного пробела.
</p>

<p>
Пустое пространство — это инструмент программиста, с помощью которого можно или сделать программу
понятной и наглядной, или изуродовать до неузнаваемости. Например, вспомним программу для мигания
светодиодом:
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT);
}
 
void loop()
{
    digitalWrite(5, HIGH);
    delay(100);
    digitalWrite(5, LOW);
    delay(900);
}</code></pre>

<p>
Мы можем изменить её так:
</p>
<br>
<pre><code class="c++">void setup(
)
    {
pinMode(5, OUTPUT);
    }
 
        void loop
    () {
digitalWrite(5,HIGH);
delay(100
)
;
    digitalWrite(5,LOW);
    delay(900); }</code></pre>

<p>
Всё, что мы сделали — немного «поработали» с пустым пространством. Теперь можно наглядно видеть
разницу между стройным кодом и нечитаемым.
</p>

<p>
Чтобы следовать негласному закону оформления программ, который уважается на форумах, при чтении
другими людьми, легко воспринимается вами же, следуйте нескольким простым правилам:
</p>

<p>
<strong>1.</strong> Всегда, при начале нового блока между <code>{</code> и <code>}</code> увеличивайте отступ. Обычно используют 2 или 4
пробела. Выберите одно из значений и придерживайтесь его всюду.
</p>

<p>
<em>Плохо:</em>
</p>
<br>
<pre><code class="c++">void loop()
{
digitalWrite(5, HIGH);
delay(100);
digitalWrite(5, LOW);
delay(900);
}</code></pre>

<p>
<em>Хорошо:</em>
</p>
<br>
<pre><code class="c++">void loop()
{
    digitalWrite(5, HIGH);
    delay(100);
    digitalWrite(5, LOW);
    delay(900);
}</code></pre>

<p>
<strong>2.</strong> Как и в естественном языке: ставьте пробел после запятых и не ставьте до.
</p>

<p>
<em>Плохо:</em>
</p>
<br>
<pre><code class="c++">digitalWrite(5,HIGH);
digitalWrite(5 , HIGH);
digitalWrite(5 ,HIGH);</code></pre>

<p>
<em>Хорошо:</em>
</p>
<br>
<pre><code class="c++">digitalWrite(5, HIGH);</code></pre>

<p>
<strong>3.</strong> Размещайте символ начала блока <code>{</code> на новой строке на текущем уровне отступа или в конце предыдущей.
А символ конца блока <code>}</code> на отдельной строке на текущем уровне отступа:
</p>

<p>
<em>Плохо:</em>
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT); }
 
void setup()
    {
    pinMode(5, OUTPUT);
    }
 
void setup()
        {
    pinMode(5, OUTPUT);
        }</code></pre>

<p>
<em>Хорошо:</em>
</p>
<br>
<pre><code class="c++">void setup()
{
    pinMode(5, OUTPUT); 
}
 
void setup() {
    pinMode(5, OUTPUT); 
}</code></pre>

<p>
<strong>4.</strong> Используйте пустые строки для разделения смысловых блоков:
</p>

<p>
<em>Хорошо:</em>
</p>
<br>
<pre><code class="c++">void loop()
{
    digitalWrite(5, HIGH);
    delay(100);
    digitalWrite(5, LOW);
    delay(900);
    digitalWrite(6, HIGH);
    delay(100);
    digitalWrite(6, LOW);
    delay(900);
}</code></pre>

<p>
<em>Ещё лучше:</em>
</p>
<br>
<pre><code class="c++">
void loop()
{
    digitalWrite(5, HIGH);
    delay(100);
 
    digitalWrite(5, LOW);
    delay(900);
 
    digitalWrite(6, HIGH);
    delay(100);
 
    digitalWrite(6, LOW);
    delay(900);
}
</code></pre>

</div>

<h2 class="sectionedit7">О точках с запятыми</h2>
<div class="level2">

<p>

Вы могли заинтересоваться: зачем в конце каждого выражения ставится точка с запятой? Таковы правила C++.
Подобные правила называются <em>синтаксисом языка</em>. По символу <code>;</code> компилятор понимает где заканчивается
выражение.
</p>

<p>
Как уже говорилось, переносы строк для него — пустой звук, поэтому ориентируется он на этот знак препинания.
Это позволяет записывать сразу несколько выражений в одной строке:
</p>
<br>
<pre><code class="c++">void loop()
{
    digitalWrite(5, HIGH); delay(100); digitalWrite(5, LOW); delay(900);
}
</code>
</pre>

<p>
Программа корректна и эквивалентна тому, что мы уже видели. Однако писать так — это дурной тон. Код
гораздо сложнее читается. Поэтому если у вас нет 100% веских причин писать в одной строке несколько
выражений, не делайте этого.
</p>

</div>

<h2 class="sectionedit8">О комментариях</h2>
<div class="level2">

<p>

Одно из правил качественного программирования: «пишите код так, чтобы он был настолько понятным, что не
нуждался бы в пояснениях». Это возможно, но не всегда. Для того, чтобы пояснить какие-то не очевидные
моменты в коде его читателям: вашим коллегам или вам самому через месяц, существуют так называемые
комментарии.
</p>

<p>
Это конструкции в программном коде, которые полностью игнорируются компилятором и имеют значение только
для читателя. Комментарии могут быть многострочными или однострочными:
</p>
<br>
<pre><code class="c++">/*
   Функция setup вызывается самой первой,
   при подаче питания на Arduino
 
   А это многострочный комментарий
 */
void setup()
{
    // устанавливаем 13-й пин в режим вывода
    pinMode(13, OUTPUT);
}
 
void loop()
{
    digitalWrite(13, HIGH);
    delay(100); // спим 100 мс
    digitalWrite(13, LOW);
    delay(900);
}</code></pre>

<p>
Как видите, между символами <code>/*</code> и <code>*/</code> можно писать сколько угодно строк комментариев.
А после последовательности <code>/</code><code>/</code> комментарием считается всё, что следует до конца строки.
</p>

<p>
Итак, надеемся самые основные принципы составления написания программ стали понятны.
Полученные знания позволяют программно управлять подачей питания на пины Arduino по
определённым временны́м схемам. Это не так уж много, но всё же достаточно для первых
экспериментов.

</p>

</div>
        </div>
      </div>

    </div> <!-- /container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../jquery.min.js"></script>
    <script src="../bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
<!--    <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>-->
  </body>
</html>
